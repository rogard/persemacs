+title persemacs-extra
#+author: Erwann Rogard
#+property: header-args :tangle no

#+name: doc-lead
#+begin_src org
  This is a standalone Emacs Org file containing emacs-lisp functionality.
#+end_src

* doc

** reference

Emacs-org:
- [[https://orgmode.org/manual/Working-with-Source-Code.html][Working with source code]]

* source
** org
*** table

#+name: tbl-foo-bar-string
| "foo" | "x" |
| "bar" | "y" |

#+name: tbl-foo-bar-dir
| "foo" | "./foo" |
| "bar" | "./bar" |

*** src

#+name: json-foo-bar
#+begin_src json
  { "key" : "X" }
#+end_src

#+RESULTS: json-foo-bar

#+name: json-foo-qux
#+begin_src json
  { "key" : "Y" }
#+end_src

#+name: bar-qux
#+header: :var value="qux"
#+begin_src sh
  echo "${value}"
#+end_src

** el
*** license

#+name: el-license
#+begin_src emacs-lisp
  ;;  persemacs-extra — extra elisp functionality
  ;;  Copyright (C) 2024—2025 — Erwann Rogard
  ;;  Released under GPL 3.0
  ;;  See https://www.gnu.org/licenses/gpl-3.0.en.html
#+end_src

*** package

#+header: :noweb-ref el-shared
#+begin_src emacs-lisp
  (use-package dash
  :ensure t)
#+end_src

*** fs
**** const
:properties:
:customize_bool: true
:end:

#+header: :noweb-ref el-fs
#+begin_src emacs-lisp
  (defconst erw/fs-unique-directory (file-name-as-directory "~/unique") "Directory for storing unique files")
#+end_src

#+RESULTS:
: erw/fs-unique-directory

**** unique-file
***** make

#+header: :noweb-ref el-fs
#+begin_src emacs-lisp
  (cl-defun erw/fs-unique-make
      (&key ((:ext ext-string))
            ((:directory directory-string) erw/fs-unique-directory)
            ((:only-name only-name-bool)) )
    "Create a uniquely named file in the given directory"
    (let* ((prefix (file-name-as-directory directory-string))
           (suffix (when ext-string (concat "." ext-string)))
           (dir-flag nil))
      (make-temp-file prefix dir-flag suffix)))
#+end_src

#+RESULTS:
: erw/fs-unique

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (let* ((directory-string nil)
    (args (append (list :ext "org" :only-name t)
                  (when directory-string (list :directory directory-string)))))
    (apply #'erw/fs-unique args))
#+end_src

#+RESULTS:
: /home/erwann/unique/A3PZfg.org

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (let* ((directory-string "~/unique")
    (args (append (list :ext "org" :only-name t)
                  (when directory-string (list :directory directory-string)))))
    (apply #'erw/fs-unique args))
#+end_src

#+RESULTS:
: /home/erwann/unique/rQa7aE.org

***** clone

#+header: :noweb-ref el-fs
#+begin_src emacs-lisp
  (cl-defun erw/fs-unique-clone
      (&key
       ((:source source-file))
       ((:directory directory-string))
       ((:do-trash trash-bool) t))
    "Clone SOURCE-FILE to a uniquely named file in DIRECTORY-STRING.
     If DO-TRASH is non-nil, move the source file to trash.
     Returns the target-file."
    (let* ((ext (file-name-extension source-file))
           (args (append (list :ext ext :only-name nil)
                         (when directory-string (list :directory directory-string))))
           (target-file (apply #'erw/fs-unique-make args)))
      (with-temp-buffer
        (insert-file-contents source-file)
        (write-region (point-min) (point-max) target-file))
      (kill-new target-file)
      (message "Cloned source file (%s) to unique file: %s" source-file target-file)
      (when trash-bool
        (move-file-to-trash source-file)
        (message "Moved source file to trash: %s" source-file))
      target-file))
#+end_src

***** interactive

#+header: :noweb-ref el-fs
#+begin_src emacs-lisp
    (cl-defun erw/fs-unique-clone-interactive
        (source-file &key
           		 ((:directory directory-string))
           		 ((:do-trash trash-bool)))
      "Interactively clone SOURCE-FILE to a uniquely named one."
      (interactive "fEnter source file")
      ;; (let (target-file)
      ;;   (let ((args (list :source source-file)))
      ;;     (dolist (string '("directory-string" "trash-bool"))
      ;;   (let ((arg (symbol-value (intern string))))
      ;;      	  (when arg
      ;;       (let ((tail (list (intern (concat ":" string)) arg)))
      ;; 	      (nconc args tail))))))
      ;;   (setq (target-file (apply #'erw/fs-unique-file-clone args))))
      ;; (kill-new target-file)  ;; Copy target file to clipboard
      ;; (message "Cloned %s to: %s (path copied to clipboard)" source-file target-file)
      )
#+end_src

#+RESULTS:
: erw/fs-unique-interactive

*** org
**** subtree

#+header: :noweb-ref el-subtree
#+begin_src emacs-lisp
  (defun erw/org-subtree--paste (target-file target-pos &optional level-fn)
    "Pastes the subtree in the clipboard into TARGET."
    (let ((level-fn (or level-fn (lambda (level) (+ level 1))))
          level)
      (with-current-buffer (find-file-noselect target-file)
        (goto-char target-pos)
        (setq level (funcall level-fn (org-current-level)))
        (org-end-of-subtree)
        (org-paste-subtree level nil nil t)
        (save-buffer))))
#+end_src

#+RESULTS:
: erw/org-subtree--paste

#+header: :noweb-ref el-subtree
#+begin_src emacs-lisp
  (defun erw/org-subtree-paste ()
    "Paste the subtree from the clipboard into the current buffer at point."
    (interactive)
    (erw/org-subtree--paste (buffer-file-name) (point)))
#+end_src

#+RESULTS:
: erw/org-subtree-paste

*** string
**** wrap-single-quotes

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/function-string-wrap-single-quotes (string)
    "Wraps STRING with single quotes if absent."
    (if (string-match-p "^'.*'$" string)
       string
      (concat "'" string "'")))
  (defalias 'erw/wrap-single-quotes 'erw/function-string-wrap-single-quotes)
#+end_src

#+RESULTS:
: erw/wrap-single-quotes

#+header: :noweb-ref elisp-example
#+begin_src emacs-lisp
  (let ((string (buffer-file-name (current-buffer))))
    (format "before: %s\nafter: %s" string 
             (funcall 'erw/wrap-single-quotes string)))
#+end_src

#+RESULTS:
: before: /home/erwann/.emacs.d/routinel.org
: after: '/home/erwann/.emacs.d/routinel.org'

**** join

#+header: :noweb-ref el-string
#+begin_src emacs-lisp
  (defun erw/string-join (&optional separator &rest strings)
    "Join STRINGS with an optional SEPARATOR, defaulting to space. Skip nil values."
    (mapconcat #'identity (delq nil strings) (or separator " ")))
#+end_src

#+RESULTS:
: erw/string-join

#+header: :noweb-ref elisp-example
#+begin_src emacs-lisp
  (erw/string-join ", " "foo" nil "qux")
#+end_src

#+RESULTS:
: foo, qux

*** table
**** field-address

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/function-table-field-address (index)
    "Table address for field INDEX"
    (format "@1$%d..@>$%d" index index))
  (defalias 'erw/field-address 'erw/function-table-field-address)
#+end_src

#+RESULTS:
: erw/field-address

#+header: :noweb-ref elisp-example
#+begin_src emacs-lisp
  (erw/field-address 2)
#+end_src

#+RESULTS:
: @1$2..@>$2

**** get-range

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/function-table-get-range-at-file (tbl-id range-address &optional file-name)
    "Get list of values in RANGE-ADDRESS from TBL-ID at FILE-NAME.
       Credits: https://redd.it/r2nig7"
    (let ((file-name (or file-name (buffer-file-name (current-buffer)))))
      (with-current-buffer (find-file-noselect file-name)
        (let ((result-with-properties
               (org-table-get-remote-range tbl-id range-address)))
          (mapcar (lambda (s)
                    (substring-no-properties (substring s 1 -1)))
                  result-with-properties)))))
  (defalias 'erw/table-range 'erw/function-table-get-range-at-file)
#+end_src

#+RESULTS:
: erw/table-range

#+header: :noweb-ref elisp-example
#+header: :results value verbatim
#+begin_src emacs-lisp
(erw/table-range "tbl-foo-bar-string" (format "@1$%d..@>$%d" 2 2))
#+end_src

#+RESULTS:
: ("x" "y")

**** lookup

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
    (defun erw/function-table-lookup (tbl-id key &optional file-name key-index value-index match-predicate)
      "Lookup field KEY-INDEX and return corresponding entry in field VALUE-INDEX from table TBL-ID."
      (interactive)
      (let ((key-address (erw/field-address (or key-index 1)))
            (value-address (erw/field-address (or value-index 2)))
            (file-name (or file-name (buffer-file-name (current-buffer))))
            (match-predicate (or match-predicate 'string-match-p)))
        (let ((key-range (erw/table-range tbl-id key-address file-name))
              (value-range (erw/table-range tbl-id value-address file-name)))
          (org-lookup-first key key-range value-range 'string-match-p))))
  (defalias 'erw/table-lookup 'erw/function-table-lookup)
#+end_src

#+RESULTS:
: erw/table-lookup

#+header: :noweb-ref elisp-example
#+begin_src emacs-lisp
(erw/table-lookup "tbl-foo-bar-string" "foo")
#+end_src

#+RESULTS:
: x

#+header: :noweb-ref elisp-example
#+begin_src emacs-lisp
(erw/table-lookup "tbl-foo-bar-string" "bar")
#+end_src

#+RESULTS:
: y

*** element

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
(defun erw/filter-block-names (regex &optional file)
  "Filter the source block names using REGEX in FILE."
  (let ((block-names (reverse (org-babel-src-block-names file))))
    (cl-remove-if-not (lambda (block) (string-match-p regex block)) block-names)))
;; (-filter (lambda (block) (string-match-p regex block)) block-names)))
#+end_src

#+RESULTS:
: erw/filter-block-names

#+begin_src emacs-lisp
  (defun erw/element-headers-as-properties (element) "Element properties retrievable using plist-get"
         (flatten-list  (mapcar (lambda (string) (org-babel-parse-header-arguments string)) (org-element-property element))))
#+end_src

*** function

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
;;  (defun erw/compose (arg &rest functions)
;;    (-reduce-r (lambda (fn acc) (funcall fn acc)) (append (reverse functions) (list arg))))
  (defun erw/compose (arg &rest functions)
  (cl-reduce (lambda (acc fn) (funcall fn acc))
             (reverse functions)
             :initial-value arg))
#+end_src

#+RESULTS:
: erw/compose

#+header: :noweb-ref elisp-example
#+begin_src emacs-lisp
  (erw/compose 4 #'sqrt (lambda (x) (+ 1 x)))
#+end_src

#+RESULTS:
: 3.0

*** noweb

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/noweb-expand (name)
    "Expands block NAME"
    (let* ((block (org-babel-find-named-block name))
  	 (info (when block
  		 (save-excursion
                     (goto-char block)
                     (org-babel-get-src-block-info t)))))
      (when info
        (org-babel-expand-noweb-references info))))
#+end_src

#+RESULTS:
: erw/noweb-expand

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun __erw/noweb-concat-rest (separator &optional fn &rest names)
    "Implementation for REST"
    (let ((fn (or fn #'identity)))
      (mapconcat (lambda (name) (funcall fn (erw/noweb-expand name))) names separator)))
  (defun __erw/noweb-concat-list (separator &optional fn names)
    "Implementation for LIST"
    (apply #'__erw/noweb-concat-rest separator fn names))
  (defun erw/noweb-concat (separator &optional fn &rest names)
    "Expand, pass to a function, and concatenate blocks using SEPARATOR, FN, and NAMES.
  Dispatches based on whether NAMES is a list or individual arguments."
    (when names
      (if (and (listp (car names)) (null (cdr names))) ;; Single list argument case
          (__erw/noweb-concat-list separator fn (car names))
        (apply #'__erw/noweb-concat-rest separator fn names))))
#+end_src

#+RESULTS:
: erw/noweb-concat

#+header: :noweb-ref elisp-example
#+begin_src emacs-lisp
  (erw/noweb-concat ", " (lambda (ex) (format "<%s>" ex)) "json-foo-bar" "json-foo-qux")
#+end_src

#+RESULTS:
: <{ "key" : "X" }>, <{ "key" : "Y" }>

#+header: :noweb-ref elisp-example
#+begin_src emacs-lisp
  (erw/noweb-concat ", " (lambda (ex) (format "<%s>" ex)) '("json-foo-bar" "json-foo-qux"))
#+end_src

#+RESULTS:
: <{ "key" : "value" }>, <{ "key" : "Y" }>

*** shell

#+header: :noweb-ref el-shell
#+begin_src emacs-lisp
  (defun erw/sh-check (command &optional re)
    "Issues a warning if the shell does not match RE; then executes shell COMMAND."
    (let ((re (or re "bash$")))
      (unless (string-match-p re (format "%s" shell-file-name))
        (warn "Warning: expecting shell to match %s; got %s" re shell-file-name))
      (shell-command-to-string command)))
#+end_src

#+RESULTS:
: erw/sh-check

#+header: :noweb-ref elisp-example
#+header: :results code
#+begin_src emacs-lisp
  (erw/sh-check "echo \"foo\"" "fish$")
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
"foo\n"
#+end_src

*** json
**** load

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (let ((prefix "./") (ext ".el"))
    (dolist (string '("shared" "string"))
      (load-file (concat prefix string ext))))
#+end_src

#+RESULTS:

**** safe

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defconst erw/json-safe-alist
    '(("\t" . "\\\\t"))
    "An association list of (REGEXP . REPLACEMENT) pairs to make strings JSON-safe.")
#+end_src

#+RESULTS:
: erw/json-safe-alist

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/json--safe (string &rest re-rep)
    "Make a STRING JSON-safe by replacing REGEXP-REPLACEMENT pairs in RE-REP"
    (if (null re-rep)
        string
      (let* ((pair (car re-rep))
             (re (car pair))
             (rep (cdr pair))
             (result (replace-regexp-in-string re rep string)))
        (apply 'erw/json--safe result (cdr re-rep)))))
#+end_src

#+RESULTS:
: erw/json--safe

#+header: :noweb-ref elisp-example
#+header: :results verbatim
#+begin_src emacs-lisp
  (erw/json--safe "{ \"key\": \"foo	bar\" }" '("\t" . "\\\\t"))
#+end_src

#+RESULTS:
: "{ \"key\": \"foo\\tbar\" }"

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/json-safe (string)
    "Recursively apply REGEXP-REPLACEMENT pairs in RE-REP to STRING."
    (apply 'erw/json--safe string erw/json-safe-alist))
#+end_src

#+RESULTS:
: erw/json-safe

#+header: :noweb-ref elisp-example
#+header: :results verbatim
#+begin_src emacs-lisp
  (erw/json-safe "{ \"key\": \"foo	bar\" }")
#+end_src

#+RESULTS:
: "{ \"key\": \"foo\\tbar\" }"

**** jq
***** file

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/jq-file (filter file &optional options)
    "Apply a jq FILTER to a JSON file and return the result."
    (let ((command (format (erw/string-join " " "jq" options "'%s'" "%s") filter file)))
      (erw/sh-check command)))
#+end_src

#+RESULTS:
: erw/jq-file

***** string

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/jq-string (filter string &optional options)
    "Apply a jq filter to a JSON string and return the result."
    (let* ((temp-file (make-temp-file nil nil ".json"))
           (result (progn
                     (with-temp-file temp-file
                       (insert string))
                     (erw/jq-file filter temp-file options))))
      (delete-file temp-file)
      (format "%s" result)))
#+end_src

#+RESULTS:
: erw/jq-string

#+header: :noweb-ref elisp-example
#+header: :results raw
#+header: :var json-object=(org-babel-ref-resolve "json-foo-bar")
#+header: :wrap src json
#+begin_src emacs-lisp  
  (erw/jq-string "." json-object "-c")
#+end_src

#+RESULTS:
#+begin_src json
{"key":"X"}
#+end_src

*** src-block

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/src-block-info (name &optional no-eval)
    "Gets info of block NAME"
    (let ((block (org-babel-find-named-block name)))
  	 (when block
  		 (save-excursion
                     (goto-char block)
                     (org-babel-get-src-block-info no-eval)))))
#+end_src

#+RESULTS:
: erw/src-block-info

#+header :noweb-ref elisp-example
#+begin_src emacs-lisp
(erw/src-block-info "json-foo-bar")
#+end_src

#+RESULTS:
| json | { "key" : "X" } | ((:colname-names) (:rowname-names) (:result-params replace) (:result-type . value) (:results . replace) (:exports . code) (:tangle . no) (:hlines . no) (:noweb . no) (:cache . no) (:session . none)) |   | json-foo-bar | 1239 | (ref:%s) |

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/src-block-element (name) "Return the whole block element"
         (save-excursion
  	 (goto-char (org-babel-find-named-block name))
  	 (org-element-at-point)))
#+end_src

#+header :noweb-ref elisp-example
#+begin_src emacs-lisp
  (erw/src-block-element "bar-qux")
#+end_src

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/src-block-properties (name &rest properties)
    "Return block properties from the named block element. Defaults to :value if no properties are given."
    (let* ((element (erw/src-block-element name))  ;; Use erw/src-block-element to get the block
           (props (if properties
                      properties
                    '(:value))))  ;; Default to :value if no properties are provided
      (mapcar (lambda (prop)
                (org-element-property prop element))  ;; Get each property using org-element-property
              props)))
#+end_src

#+header: :noweb-ref elisp-example
#+header: :results verbatim raw
#+begin_src emacs-lisp
  (erw/src-block-properties "bar-qux" :header)
#+end_src

#+RESULTS:
((":var value=\"qux\""))

#+header :noweb-ref elisp-example
#+begin_src emacs-lisp
  (org-babel-parse-header-arguments
   (mapconcat (lambda (pair) (concat (car pair) " " (cadr pair)))
              (erw/src-block-properties "bar-qux" :header)
              " "))
#+end_src

#+RESULTS:
: ((:var . value="qux"))

* tangle
** shared
:PROPERTIES:
:header-args: :tangle ./shared.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-shared>>
#+end_src

#+RESULTS:
: erw/noweb-concat

** subtree
:PROPERTIES:
:header-args: :tangle ./subtree.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-subtree>>
#+end_src

#+RESULTS:
: erw/noweb-concat

** string
:PROPERTIES:
:header-args: :tangle ./string.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-string>>
#+end_src

** shell
:PROPERTIES:
:header-args: :tangle ./shell.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-shell>>
#+end_src

** fs
:PROPERTIES:
:header-args: :tangle ../el/fs.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-fs>>
#+end_src

* scratch

#+begin_src emacs-lisp
  (cl-defun my-func (source-file
  		   &key
         		   ((:directory directory-string))
         		   ((:do-trash trash-bool)))    
    "Interactively clone SOURCE-FILE to a uniquely named one."
    (interactive "fEnter source file")
    (message "debug: %s" source-file) )
#+end_src

#+RESULTS:
: my-func
