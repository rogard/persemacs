+title persemacs-extra
#+author: Erwann Rogard
#+property: header-args :tangle no

#+name: doc-lead
#+begin_src org
  This is a standalone Emacs Org file containing emacs-lisp functionality.
#+end_src

* doc

** reference

Emacs-org:
- [[https://orgmode.org/manual/Working-with-Source-Code.html][Working with source code]]

* source
** org
*** table

#+name: tbl-foo-bar-string
| "foo" | "x" |
| "bar" | "y" |

#+name: tbl-foo-bar-dir
| "foo" | "./foo" |
| "bar" | "./bar" |

*** src

#+name: json-foo-bar
#+begin_src json
  { "key" : "X" }
#+end_src

#+RESULTS: json-foo-bar

#+name: json-foo-qux
#+begin_src json
  { "key" : "Y" }
#+end_src

#+name: bar-qux
#+header: :var value="qux"
#+begin_src sh
  echo "${value}"
#+end_src

** el
*** fs
**** unique-file
***** load
****** code

#+header: :noweb-ref el-fs
#+begin_src emacs-lisp
  (load-file "../el/list.el")
#+end_src

***** directory
:properties:
:customize_bool: true
:end:

****** code

#+header: :noweb-ref el-fs
#+begin_src emacs-lisp
  (defconst erw/filesys-unique-directory (file-name-as-directory "~/unique") "Directory for storing unique files")
#+end_src

#+RESULTS:
: erw/filesys-unique-directory

***** make
****** code

#+header: :noweb-ref el-fs
#+begin_src emacs-lisp
  (cl-defun erw/filesys-unique-make
      (&key ((:ext ext-string))
            ((:directory directory-string) erw/filesys-unique-directory)
            ((:only-name only-name-bool)))
    "Create a uniquely named file in the given directory"
    (let* ((prefix (file-name-as-directory directory-string))
           (suffix (when ext-string (concat "." ext-string)))
           (dir-flag nil))
      (make-temp-file prefix dir-flag suffix)))
#+end_src

#+RESULTS:
: erw/filesys-unique-make

****** example

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (let* ((directory-string nil)
    (args (append (list :ext "org" :only-name t)
                  (when directory-string (list :directory directory-string)))))
    (apply #'erw/filesys-unique-make args))
#+end_src

#+RESULTS:
: /home/erwann/unique/ZlyJWc.org

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (let* ((directory-string "~/unique")
    (args (append (list :ext "org" :only-name t)
                  (when directory-string (list :directory directory-string)))))
    (apply #'erw/filesys-unique-make args))
#+end_src

#+RESULTS:
: /home/erwann/unique/GPmUqe.org

***** clone
****** code

#+header: :noweb-ref el-fs
#+begin_src emacs-lisp
  (cl-defun erw/filesys-unique-clone
      (&key
       ((:source source-file))
       ((:directory directory-string))
       ((:do-trash trash-bool) t))
    "Clone SOURCE-FILE to a uniquely named file in DIRECTORY-STRING.
         If DO-TRASH is non-nil, move the source file to trash.
         Returns the target-file."
    (let ((target-file
  	 (let ((args (erw/plist-if :ext (file-name-extension source-file) :only-name nil :directory directory-string)))
    	   (apply #'erw/filesys-unique-make args))))
      (with-temp-buffer
        (insert-file-contents source-file)
        (write-region (point-min) (point-max) target-file))
      (kill-new target-file)
      (message "Cloned source file (%s) to unique file: %s" source-file target-file)
      (when trash-bool
        (move-file-to-trash source-file)
        (message "Moved source file to trash: %s" source-file))
      target-file))
#+end_src

#+RESULTS:
: erw/filesys-unique-clone

***** interactive
****** code

#+header: :noweb-ref el-fs
#+begin_src emacs-lisp
  (cl-defun erw/filesys-unique-clone-interactive
      (source-file &key
                   ((:directory directory-string))
                   ((:do-trash trash-bool)))
    "Interactively clone SOURCE-FILE to a uniquely named one."
    (interactive "fEnter source file")
    ;; Warn if the source file is open in any buffer
    (dolist (buf (buffer-list))
      (when (and (buffer-file-name buf)
                 (file-equal-p source-file (buffer-file-name buf)))
        (warn "About to clone the file opened in buffer: %s" (buffer-name buf))))
    ;; Prepare arguments and call the cloning function
    (let ((plist (erw/plist-if :source source-file :directory directory-string :do-trash trash-bool)))
      (let ((target-file (apply #'erw/filesys-unique-clone plist)))
      (kill-new target-file)
      (message "Cloned %s to: %s (path copied to clipboard)" source-file target-file))))
#+end_src

#+RESULTS:
: erw/filesys-unique-clone-interactive

*** function
**** code

#+header: :noweb-ref el-function
#+begin_src emacs-lisp
  (defun erw/compose (arg &rest functions)
    "Apply a sequence of FUNCTIONS to ARG in composition order."
    (cl-reduce (lambda (acc fn) (funcall fn acc))
               (reverse functions)
               :initial-value arg))
#+end_src

#+RESULTS:
: erw/compose

**** example

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (erw/compose 4 #'sqrt (lambda (x) (+ 1 x)))
#+end_src

#+RESULTS:
: 3.0

*** json
**** load
****** code

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (let ((prefix "./") (ext ".el"))
    (dolist (string '("shared" "string"))
      (load-file (concat prefix string ext))))
#+end_src

#+RESULTS:

**** safe
****** code

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defconst erw/json-safe-alist
    '(("\t" . "\\\\t"))
    "An association list of (REGEXP . REPLACEMENT) pairs to make strings JSON-safe.")
#+end_src

#+RESULTS:
: erw/json-safe-alist

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/json--safe (string &rest re-rep)
    "Make a STRING JSON-safe by replacing REGEXP-REPLACEMENT pairs in RE-REP"
    (if (null re-rep)
        string
      (let* ((pair (car re-rep))
             (re (car pair))
             (rep (cdr pair))
             (result (replace-regexp-in-string re rep string)))
        (apply 'erw/json--safe result (cdr re-rep)))))
#+end_src

#+RESULTS:
: erw/json--safe

****** example

#+header: :noweb-ref el-example
#+header: :results verbatim
#+begin_src emacs-lisp
  (erw/json--safe "{ \"key\": \"foo	bar\" }" '("\t" . "\\\\t"))
#+end_src

#+RESULTS:
: "{ \"key\": \"foo\\tbar\" }"

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/json-safe (string)
    "Recursively apply REGEXP-REPLACEMENT pairs in RE-REP to STRING."
    (apply 'erw/json--safe string erw/json-safe-alist))
#+end_src

#+RESULTS:
: erw/json-safe

#+header: :noweb-ref el-example
#+header: :results verbatim
#+begin_src emacs-lisp
  (erw/json-safe "{ \"key\": \"foo	bar\" }")
#+end_src

#+RESULTS:
: "{ \"key\": \"foo\\tbar\" }"

**** jq
***** file
****** code

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/jq-file (filter file &optional options)
    "Apply a jq FILTER to a JSON file and return the result."
    (let ((command (format (erw/string-join " " "jq" options "'%s'" "%s") filter file)))
      (erw/sh-check command)))
#+end_src

#+RESULTS:
: erw/jq-file

***** string
****** code

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/jq-string (filter string &optional options)
    "Apply a jq filter to a JSON string and return the result."
    (let* ((temp-file (make-temp-file nil nil ".json"))
           (result (progn
                     (with-temp-file temp-file
                       (insert string))
                     (erw/jq-file filter temp-file options))))
      (delete-file temp-file)
      (format "%s" result)))
#+end_src

#+RESULTS:
: erw/jq-string

****** example

#+header: :noweb-ref el-example
#+header: :results raw
#+header: :var json-object=(org-babel-ref-resolve "json-foo-bar")
#+header: :wrap src json
#+begin_src emacs-lisp  
  (erw/jq-string "." json-object "-c")
#+end_src

#+RESULTS:
#+begin_src json
{"key":"X"}
#+end_src

*** license

#+name: el-license
#+begin_src emacs-lisp
  ;;  persemacs-extra — extra elisp functionality
  ;;  Copyright (C) 2024—2025 — Erwann Rogard
  ;;  Released under GPL 3.0
  ;;  See https://www.gnu.org/licenses/gpl-3.0.en.html
#+end_src

*** list
**** code

#+header: :noweb-ref el-list
#+begin_src emacs-lisp
  (cl-defun erw/plist-if (&rest keyval-list)
    "Return a plist containing only the key-value pairs from KEYVAL-LIST
whose values are non-nil."
    (let ((result nil))
      (while keyval-list
        (let ((key (pop keyval-list))
              (value (pop keyval-list)))
          (when value
            (setq result (append result (list key value))))))
      result))
#+end_src

#+RESULTS:
: erw/plist-if

**** example


#+header: :results raw verbatim
#+begin_src emacs-lisp
  (plist-get (erw/plist-if :foo "foo" :bar nil :qux "qux") :qux)
#+end_src

#+RESULTS:
"qux"

*** noweb
**** code

#+header: :noweb-ref el-noweb
#+begin_src emacs-lisp
  (cl-defun erw/noweb-expand-ref (&key regex)
    "Expands all source blocks whose :noweb-ref matches REGEX and returns their expanded contents, joined by SEP."
    (let ((results '()))
      (org-element-map (org-element-parse-buffer) 'src-block
        (lambda (src)
          (let* ((begin (org-element-property :begin src))
                 (info (save-excursion
                         (goto-char begin)
                         (org-babel-get-src-block-info t)))
                 (params (nth 2 info))  ; header arguments parsed by org-babel
                 (ref (cdr (assoc :noweb-ref params))))
            (message "debug parsed params: %S" params)
            (when (and ref (string-match-p regex ref))
              (let ((expanded (org-babel-expand-noweb-references info)))
                (push expanded results))))))
      (nreverse results)))
#+end_src

#+RESULTS:
: erw/noweb-expand-ref

#+header: :noweb-ref el-noweb
#+begin_src emacs-lisp
  (cl-defun erw/noweb-expand-ref-collect (&key head ref-list tail)
    "Builds a regex from REF-LIST with optional HEAD and TAIL anchors, then forwards to `erw/noweb-expand-ref`."
    (let* ((regex-body (mapconcat #'identity ref-list "\\|"))
           (regex (concat (or head "") "\\(" regex-body "\\)" (or tail "")))
           (args `(:regex ,regex)))
      (apply #'erw/noweb-expand-ref args)))
#+end_src

#+RESULTS:
: erw/noweb-expand-ref-collect

#+RESULTS:
: foobar

**** example

#+header: :noweb-ref sh-foo
#+begin_src sh
  echo 'Hello, world!'
#+end_src

#+header: :noweb-ref sh-bar
#+begin_src sh
  echo 'Hello, universe!'
#+end_src

#+header: :noweb yes
#+header: :results verbatim
#+begin_src emacs-lisp
(erw/noweb-expand-ref :regex "sh-foo\\|bar")
#+end_src

#+RESULTS:
: ("echo 'Hello, world!'" "echo 'Hello, universe!'")

#+header: :results verbatim
#+begin_src emacs-lisp
  (erw/noweb-expand-ref-collect :head "sh-" :ref-list '("foo" "bar"))
#+end_src

#+RESULTS:
: ("echo 'Hello, world!'" "echo 'Hello, universe!'")

*** org
**** element
***** code

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/filter-block-names (regex &optional file)
    "Filter the source block names using REGEX in FILE."
    (let ((block-names (reverse (org-babel-src-block-names file))))
      (cl-remove-if-not (lambda (block) (string-match-p regex block)) block-names)))
#+end_src

#+RESULTS:
: erw/filter-block-names

#+begin_src emacs-lisp
  (defun erw/element-headers-as-properties (element) "Element properties retrievable using plist-get"
         (flatten-list  (mapcar (lambda (string) (org-babel-parse-header-arguments string)) (org-element-property element))))
#+end_src

**** subtree
***** paste
****** code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (defun erw/org-subtree-paste (target-file target-pos &optional level-fn)
    "Pastes the subtree in the clipboard into TARGET."
    (let ((level-fn (or level-fn (lambda (level) (+ level 1))))
          level)
      (with-current-buffer (find-file-noselect target-file)
        (goto-char target-pos)
        (setq level (funcall level-fn (org-current-level)))
        (org-end-of-subtree)
        (org-paste-subtree level nil nil t)
        (save-buffer))))
#+end_src

#+RESULTS:
: erw/org-subtree--paste

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (defun erw/org-subtree-paste-interactive ()
    "Paste the subtree from the clipboard into the current buffer at point."
    (interactive)
    (erw/org-subtree-paste (buffer-file-name) (point)))
#+end_src

#+RESULTS:
: erw/org-subtree-paste

***** promote
****** code

#+begin_src emacs-lisp
(defun erw/org-subtree-promote ()
  "Promote the current Org subtree.

If the top heading is level 1, replace it with a `#+TITLE:` line,
then promote the rest of the subtree."
  (interactive)
  (save-excursion
    (org-back-to-heading t)
    (let ((level (org-current-level))
          (title (org-get-heading t t t t))
          (heading-start (point))
          region-start region-end)
      (if (= level 1)
          (progn
            ;; Save where heading starts
            (setq region-start (progn
                                 (forward-line 1)
                                 (point)))
            (org-end-of-subtree t t)
            (setq region-end (point))

            ;; Replace heading line with #+TITLE:
            (goto-char heading-start)
            (delete-region (line-beginning-position) (1+ (line-end-position)))
            (insert (format "#+TITLE: %s\n" title))

            ;; Promote nested subtree (if any)
            (when (< region-start region-end)
              (org-map-region
               (lambda () (org-promote-subtree))
               region-start region-end)))
        ;; Otherwise just promote normally
        (org-promote-subtree)))))
#+end_src

#+RESULTS:
: erw/org-subtree-promote

**** refactor
***** define
****** code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (cl-defmacro erw/org-refactor-define (&key
      					     ((:source source-fn))
      					     ((:args args-lambda))
      					     ((:result result-lambda))
      					     ((:target target-fn)))
    `(cl-defun ,target-fn (&rest keyval)
       ,(format "Wrapper around `%s` with optional input/output transformation." source-fn)
       (let* ((result-raw (if ,args-lambda
                              (let ((args-list (apply ,args-lambda keyval)))
                                (apply ,source-fn args-list))
                            (,source-fn)))
              (result (if ,result-lambda
  			(funcall ,result-lambda result-raw)
                        (progn
  			(warn "No output function found for %s; returning raw output instead" ',target-fn)
  			result-raw))))
         result)))
#+end_src

#+RESULTS:
: erw/org-refactor-define

****** example

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
    (defun my-source-fn (x y) (+ x y))
#+end_src

#+RESULTS:
: my-source-fn

#+header: :noweb-ref el-example
#+begin_src emacs-lisp  
  (erw/org-refactor-define
   :source 'my-source-fn
   :args (lambda (&rest kv) (list (plist-get kv :x) (plist-get kv :y))) ;; ignore input
   :result (lambda (result) (* result 10))
   :target my-wrapped-fn)
#+end_src

#+RESULTS:
: my-wrapped-fn

#+header: :noweb-ref el-example
#+begin_src emacs-lisp  
  (my-wrapped-fn :x 2 :y 3) ;; => 30
#+end_src

#+RESULTS:
: 50

***** apply
****** code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (erw/org-refactor-define
   :source org-heading-components
   :target erw/org-heading-components
   :args nil
   :result (lambda (list)
             (let ((keyval-list '(:level 0 :reduced-level 1 :todo-keyword 2 :priority 3 :headline 4 :tags 5))
                   (result '()))
               (while keyval-list
                 (let ((key (pop keyval-list))
                       (pos (pop keyval-list)))
                   (push key result)
                   (push (nth pos list) result)))
               (nreverse result))))
#+end_src

#+RESULTS:
: erw/org-heading-components

**** global
****** code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (cl-defun erw/org-global-header-position-next (&optional buffer)
    "Return the BUFFER position where the next global header line (e.g. `#+property:`) should be inserted."
    (with-current-buffer (or buffer (current-buffer))
      (save-excursion
        (goto-char (point-min))
        (while (looking-at "^#\\+\\w+:")
          (forward-line 1))
        (point))))
#+end_src

**** property
***** define
****** code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (cl-defmacro erw/org-property-define (&key
                                        ((:name name-symb))
                                        ((:key key-string))
                                        ((:value value-lambda)))
    "Create a function NAME-SYMB to set Org property KEY-STRING using VALUE-LAMBDA."
    (let ((name-symb (or name-symb
                         (intern (concat "erw/org-property-" key-string)))))
      `(cl-defun ,name-symb (&rest keyval)
         ,(format "Set the Org property %s using a computed value." key-string)
         (let ((value (save-excursion (apply ,value-lambda keyval))))
           (org-set-property ,key-string value)))))
#+end_src

#+RESULTS:
: erw/org-property-define

***** apply
****** code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (erw/org-property-define
   :key "parent-id"
   :value (lambda ()
            (when (org-up-heading-safe)
              (org-id-get-create))))
#+end_src

#+RESULTS:
: erw/org-property-parent-id

*** shell
**** code

#+header: :noweb-ref el-shell
#+begin_src emacs-lisp
  (defun erw/sh-check (command &optional re)
    "Issues a warning if the shell does not match RE; then executes shell COMMAND."
    (let ((re (or re "bash$")))
      (unless (string-match-p re (format "%s" shell-file-name))
        (warn "Warning: expecting shell to match %s; got %s" re shell-file-name))
      (shell-command-to-string command)))
#+end_src

#+RESULTS:
: erw/sh-check

**** example

#+header: :noweb-ref el-example
#+header: :results code
#+begin_src emacs-lisp
  (erw/sh-check "echo \"foo\"" "fish$")
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
"foo\n"
#+end_src

*** src-block
**** code

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/src-block-info (name &optional no-eval)
    "Gets info of block NAME"
    (let ((block (org-babel-find-named-block name)))
  	 (when block
  		 (save-excursion
                     (goto-char block)
                     (org-babel-get-src-block-info no-eval)))))
#+end_src

#+RESULTS:
: erw/src-block-info

**** example

#+header :noweb-ref el-example
#+begin_src emacs-lisp
(erw/src-block-info "json-foo-bar")
#+end_src

#+RESULTS:
| json | { "key" : "X" } | ((:colname-names) (:rowname-names) (:result-params replace) (:result-type . value) (:results . replace) (:exports . code) (:tangle . no) (:hlines . no) (:noweb . no) (:cache . no) (:session . none)) |   | json-foo-bar | 1239 | (ref:%s) |

#+header: :noweb-ref el-example
#+header: :results verbatim raw
#+begin_src emacs-lisp
  (erw/src-block-properties "bar-qux" :header)
#+end_src

#+RESULTS:
((":var value=\"qux\""))

#+header :noweb-ref el-example
#+begin_src emacs-lisp
  (org-babel-parse-header-arguments
   (mapconcat (lambda (pair) (concat (car pair) " " (cadr pair)))
              (erw/src-block-properties "bar-qux" :header)
              " "))
#+end_src

#+RESULTS:
: ((:var . value="qux"))

*** string
**** wrap-single-quotes
***** code
#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/function-string-wrap-single-quotes (string)
    "Wraps STRING with single quotes if absent."
    (if (string-match-p "^'.*'$" string)
       string
      (concat "'" string "'")))
  (defalias 'erw/wrap-single-quotes 'erw/function-string-wrap-single-quotes)
#+end_src

#+RESULTS:
: erw/wrap-single-quotes

***** example
#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (let ((string (buffer-file-name (current-buffer))))
    (format "before: %s\nafter: %s" string 
             (funcall 'erw/wrap-single-quotes string)))
#+end_src

#+RESULTS:
: before: /home/erwann/.emacs.d/routinel.org
: after: '/home/erwann/.emacs.d/routinel.org'

**** join
***** code

#+header: :noweb-ref el-string
#+begin_src emacs-lisp
  (defun erw/string-join (&optional separator &rest strings)
    "Join STRINGS with an optional SEPARATOR, defaulting to space. Skip nil values."
    (mapconcat #'identity (delq nil strings) (or separator " ")))
#+end_src

#+RESULTS:
: erw/string-join

***** example

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (erw/string-join ", " "foo" nil "qux")
#+end_src

#+RESULTS:
: foo, qux

*** table
**** field-address
***** code
#+header: :noweb-ref el-table
#+begin_src emacs-lisp
  (defun erw/function-table-field-address (index)
    "Table address for field INDEX"
    (format "@1$%d..@>$%d" index index))
  (defalias 'erw/field-address 'erw/function-table-field-address)
#+end_src

#+RESULTS:
: erw/field-address

***** example
#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (erw/field-address 2)
#+end_src

#+RESULTS:
: @1$2..@>$2

**** get-range
***** code
#+header: :noweb-ref el-table
#+begin_src emacs-lisp
  (defun erw/function-table-get-range-at-file (tbl-id range-address &optional file-name)
    "Get list of values in RANGE-ADDRESS from TBL-ID at FILE-NAME.
       Credits: https://redd.it/r2nig7"
    (let ((file-name (or file-name (buffer-file-name (current-buffer)))))
      (with-current-buffer (find-file-noselect file-name)
        (let ((result-with-properties
               (org-table-get-remote-range tbl-id range-address)))
          (mapcar (lambda (s)
                    (substring-no-properties (substring s 1 -1)))
                  result-with-properties)))))
  (defalias 'erw/table-range 'erw/function-table-get-range-at-file)
#+end_src

#+RESULTS:
: erw/table-range

***** example

#+header: :noweb-ref el-example
#+header: :results value verbatim
#+begin_src emacs-lisp
(erw/table-range "tbl-foo-bar-string" (format "@1$%d..@>$%d" 2 2))
#+end_src

#+RESULTS:
: ("x" "y")

**** lookup
***** code
#+header: :noweb-ref el-table
#+begin_src emacs-lisp
    (defun erw/function-table-lookup (tbl-id key &optional file-name key-index value-index match-predicate)
      "Lookup field KEY-INDEX and return corresponding entry in field VALUE-INDEX from table TBL-ID."
      (interactive)
      (let ((key-address (erw/field-address (or key-index 1)))
            (value-address (erw/field-address (or value-index 2)))
            (file-name (or file-name (buffer-file-name (current-buffer))))
            (match-predicate (or match-predicate 'string-match-p)))
        (let ((key-range (erw/table-range tbl-id key-address file-name))
              (value-range (erw/table-range tbl-id value-address file-name)))
          (org-lookup-first key key-range value-range 'string-match-p))))
  (defalias 'erw/table-lookup 'erw/function-table-lookup)
#+end_src

#+RESULTS:
: erw/table-lookup

***** example

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
(erw/table-lookup "tbl-foo-bar-string" "foo")
#+end_src

#+RESULTS:
: x

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
(erw/table-lookup "tbl-foo-bar-string" "bar")
#+end_src

#+RESULTS:
: y

* tangle
** noweb
:PROPERTIES:
:header-args: :tangle "../el/noweb.el"
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-noweb>>
#+end_src

** org
:PROPERTIES:
:header-args: :tangle "../el/org.el"
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-org>>
#+end_src

#+RESULTS:
: erw/noweb-concat

** string
:PROPERTIES:
:header-args: :tangle ./string.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-string>>
#+end_src

** shell
:PROPERTIES:
:header-args: :tangle ./shell.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-shell>>
#+end_src

** fs
:PROPERTIES:
:header-args: :tangle ../el/fs.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-fs>>
#+end_src

** list
:PROPERTIES:
:header-args: :tangle ../el/list.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-list>>
#+end_src

* scratch

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/src-block-element (name) "Return the whole block element"
         (save-excursion
  	 (goto-char (org-babel-find-named-block name))
  	 (org-element-at-point)))
#+end_src

#+header :noweb-ref el-example
#+begin_src emacs-lisp
  (erw/src-block-element "bar-qux")
#+end_src

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/src-block-properties (name &rest properties)
    "Return block properties from the named block element. Defaults to :value if no properties are given."
    (let* ((element (erw/src-block-element name))  ;; Use erw/src-block-element to get the block
           (props (if properties
                      properties
                    '(:value))))  ;; Default to :value if no properties are provided
      (mapcar (lambda (prop)
                (org-element-property prop element))  ;; Get each property using org-element-property
              props)))
#+end_src

** package

#+header: :noweb-ref el-leaveout
#+begin_src emacs-lisp
  (use-package dash
    :ensure t)
#+end_src

** id-link
*** const

#+property: p


#+begin_src emacs-lisp
    (defconst erw/org-property-rdf
  '(:primary-key "rdf-like"
    :secondary-key '(
  		   :predicate
  		   :object
  		   )
      
      "db-like" "Main key")
#+end_src

#+begin_src emacs-lisp
  (defconst erw/org-property-db-optional-keys '(collection predicate type) "Optional secondary keys")
#+end_src

#+RESULTS:
: erw/org-property-db-optional-keys

*** set-helper

#+begin_src emacs-lisp
  (defun erw/org-property-plist-helper (primary-key secondary-key-list &rest plist)
    ""
      (let ((parts '()))
        ;; Collect optional key-value pairs
        (dolist (k secondary-key-list)
          (let ((val (plist-get plist k)))
            (when val
              (push (format ":%s %s" (substring (symbol-name k) 1) val) parts))))
        (let ((property-value (string-join (nreverse parts) " "))
              (property-name (if (org-entry-get (point) primary-key)
                                 (concat primary-key "+")
                               primary-key)))
          (org-set-property property-name property-value)))))
#+end_src

#+RESULTS:
: set-erw-graph-property

*** set

#+begin_src emacs-lisp
(eval-and-compile
  (let* ((optional-args (mapcar (lambda (k) (list k)) erw/org-property-db-optional-keys))
         (arglist `(&key ,@optional-args id secondary-key))
         (forward-body
          `(apply #'erw/org-property-db-set-helper
                  "erw-link"
                  ',erw/org-property-db-optional-keys
                  (list
                   ,@(apply #'append
                            (mapcar (lambda (k) `(',k ,k))
                                    (append erw/org-property-db-optional-keys '(:id :secondary-key))))))))
    (eval `(cl-defun erw/org-property-db-set ,arglist
             ,(format "Auto-generated wrapper forwarding to `erw/org-property-db-set-helper`.\nOptional keys: %s"
                      erw/org-property-db-optional-keys)
             ,forward-body))))
#+end_src


#+begin_src emacs-lisp
  (cl-defun my-func (source-file
  		   &key
         		   ((:directory directory-string))
         		   ((:do-trash trash-bool)))    
    "Interactively clone SOURCE-FILE to a uniquely named one."
    (interactive "fEnter source file")
    (message "debug: %s" source-file) )
#+end_src

#+RESULTS:
: my-func

#+begin_src emacs-lisp
  (erw/filesys-unique-clone :source "/home/erwann/src/org/AiSv8K.org")
#+end_src

#+RESULTS:
: /home/erwann/unique/xxYG8M.org

* trash
*** noweb


#+begin_src emacs-lisp
  (defun erw/noweb-expand (name)
    "Expands block NAME"
    (let* ((block (org-babel-find-named-block name))
  	 (info (when block
  		 (save-excursion
                     (goto-char block)
                     (org-babel-get-src-block-info t)))))
      (when info
        (org-babel-expand-noweb-references info))))
#+end_src

#+RESULTS:
: erw/noweb-expand


#+begin_src emacs-lisp
  (defun __erw/noweb-concat-rest (separator &optional fn &rest names)
    "Implementation for REST"
    (let ((fn (or fn #'identity)))
      (mapconcat (lambda (name) (funcall fn (erw/noweb-expand name))) names separator)))
  (defun __erw/noweb-concat-list (separator &optional fn names)
    "Implementation for LIST"
    (apply #'__erw/noweb-concat-rest separator fn names))
  (defun erw/noweb-concat (separator &optional fn &rest names)
    "Expand, pass to a function, and concatenate blocks using SEPARATOR, FN, and NAMES.
  Dispatches based on whether NAMES is a list or individual arguments."
    (when names
      (if (and (listp (car names)) (null (cdr names))) ;; Single list argument case
          (__erw/noweb-concat-list separator fn (car names))
        (apply #'__erw/noweb-concat-rest separator fn names))))
#+end_src

#+RESULTS:
: erw/noweb-concat

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (erw/noweb-concat ", " (lambda (ex) (format "<%s>" ex)) "json-foo-bar" "json-foo-qux")
#+end_src

#+RESULTS:
: <{ "key" : "X" }>, <{ "key" : "Y" }>

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (erw/noweb-concat ", " (lambda (ex) (format "<%s>" ex)) '("json-foo-bar" "json-foo-qux"))
#+end_src

#+RESULTS:
: <{ "key" : "value" }>, <{ "key" : "Y" }>


