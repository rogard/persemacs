#+title persemacs-extra
#+author: Erwann Rogard
#+property: header-args :tangle no

#+name: doc-lead
#+begin_src org
  This is a standalone Emacs Org file containing emacs-lisp functionality.
#+end_src

* doc

** reference

Emacs-org:
- [[https://orgmode.org/manual/Working-with-Source-Code.html][Working with source code]]

* source
** org
*** test-cases
**** tbl

#+name: tbl-foo-bar-string
| "foo" | "x" |
| "bar" | "y" |

#+name: tbl-foo-bar-dir
| "foo" | "./foo" |
| "bar" | "./bar" |
*** TODO
**** tangle
:PROPERTIES:
:created_on: <2025-05-22 Thu 20:10>
:uname:    @elitebook
:END:
:LOGBOOK:
- Note taken on [2025-05-22 Thu 20:11] \\
  TARGET-FILE not seem reliable
:END:

#+begin_src emacs-lisp
  (org-babel-tangle &optional ARG TARGET-FILE LANG-RE)
#+end_src

** el
*** license

#+name: el-license
#+begin_src emacs-lisp
  ;;  persemacs-extra ‚Äî extra elisp functionality
  ;;  Copyright (C) 2024‚Äî2025 ‚Äî Erwann Rogard
  ;;  Released under GPL 3.0
  ;;  See https://www.gnu.org/licenses/gpl-3.0.en.html
#+end_src

*** module
*** filesys
**** preamble

#+header: :noweb-ref el-filesys
#+begin_src emacs-lisp
  (load-file "../el/list.el")
#+end_src

**** module
***** unique-file
****** directory
:properties:
:customize_bool: true
:end:

#+header: :noweb-ref el-filesys
#+begin_src emacs-lisp
  (defconst erw/filesys-unique-directory (file-name-as-directory "~/unique") "Directory for storing unique files")
#+end_src

#+RESULTS:
: erw/filesys-unique-directory

****** make

#+header: :noweb-ref el-filesys
#+begin_src emacs-lisp
  (cl-defun erw/filesys-unique-make
      (&key ((:ext ext-string))
            ((:directory directory-string) erw/filesys-unique-directory)
            ((:only-name only-name-bool)))
    "Create a uniquely named file in the given directory"
    (let* ((prefix (file-name-as-directory directory-string))
           (suffix (when ext-string (concat "." ext-string)))
           (dir-flag nil))
      (make-temp-file prefix dir-flag suffix)))
#+end_src

#+RESULTS:
: erw/filesys-unique-make

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (let* ((directory-string nil)
    (args (append (list :ext "org" :only-name t)
                  (when directory-string (list :directory directory-string)))))
    (apply #'erw/filesys-unique-make args))
#+end_src

#+RESULTS:
: /home/erwann/unique/ZlyJWc.org

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (let* ((directory-string "~/unique")
    (args (append (list :ext "org" :only-name t)
                  (when directory-string (list :directory directory-string)))))
    (apply #'erw/filesys-unique-make args))
#+end_src

#+RESULTS:
: /home/erwann/unique/GPmUqe.org

****** clone

#+header: :noweb-ref el-filesys
#+begin_src emacs-lisp
  (cl-defun erw/filesys-unique-clone
      (&key
       ((:source source-file))
       ((:directory directory-string))
       ((:do-trash trash-bool) t))
    "Clone SOURCE-FILE to a uniquely named file in DIRECTORY-STRING.
         If DO-TRASH is non-nil, move the source file to trash.
         Returns the target-file."
    (let ((target-file
  	 (let ((args (erw/plist-if :ext (file-name-extension source-file) :only-name nil :directory directory-string)))
    	   (apply #'erw/filesys-unique-make args))))
      (with-temp-buffer
        (insert-file-contents source-file)
        (write-region (point-min) (point-max) target-file))
      (kill-new target-file)
      (message "Cloned source file (%s) to unique file: %s" source-file target-file)
      (when trash-bool
        (move-file-to-trash source-file)
        (message "Moved source file to trash: %s" source-file))
      target-file))
#+end_src

#+RESULTS:
: erw/filesys-unique-clone

****** interactive
******* code

#+header: :noweb-ref el-filesys
#+begin_src emacs-lisp
  (cl-defun erw/filesys-unique-clone-interactive
      (source-file &key
                   ((:directory directory-string))
                   ((:do-trash trash-bool)))
    "Interactively clone SOURCE-FILE to a uniquely named one."
    (interactive "fEnter source file")
    ;; Warn if the source file is open in any buffer
    (dolist (buf (buffer-list))
      (when (and (buffer-file-name buf)
                 (file-equal-p source-file (buffer-file-name buf)))
        (warn "About to clone the file opened in buffer: %s" (buffer-name buf))))
    ;; Prepare arguments and call the cloning function
    (let ((plist (erw/plist-if :source source-file :directory directory-string :do-trash trash-bool)))
      (let ((target-file (apply #'erw/filesys-unique-clone plist)))
      (kill-new target-file)
      (message "Cloned %s to: %s (path copied to clipboard)" source-file target-file))))
#+end_src

#+RESULTS:
: erw/filesys-unique-clone-interactive

*** function
**** module
***** compose
#+header: :noweb-ref el-function
#+begin_src emacs-lisp
  (defun erw/compose (arg &rest functions)
    "Apply a sequence of FUNCTIONS to ARG in composition order."
    (cl-reduce (lambda (acc fn) (funcall fn acc))
               (reverse functions)
               :initial-value arg))
#+end_src

#+RESULTS:
: erw/compose

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (erw/compose 4 #'sqrt (lambda (x) (+ 1 x)))
#+end_src

#+RESULTS:
: 3.0

*** json
**** notes
:PROPERTIES:
:created_on: <2025-05-23 Fri 11:50>
:uname:    @elitebook
:END:
:LOGBOOK:
- Note taken on [2025-05-23 Fri 11:51] \\
  erw/json-safe to be trashed? Seems like json-* functions could do that.
:END:

#+begin_src markdown
```elisp
(erw/json--safe "{ \"key\": \"foo\tbar\" }" '("\t" . "\\\\t"))
````

You‚Äôre asking: **Isn't this kind of escaping already handled by `json-encode` or similar built-in functions in Emacs?**

---

### ‚úÖ Short Answer

Yes ‚Äî **`json-encode` already escapes special characters** like `\t`, `\n`, `\"`, etc.
So if you're building your JSON with **Lisp structures** and then using `json-encode`, **you don't need to escape strings manually**.

---

### üîç But Here's the Important Distinction

Your function is processing a **raw JSON string**, not a Lisp structure.

So:

```elisp
(erw/json-safe "{ \"key\": \"foo\tbar\" }")
```

‚Ä¶takes in a JSON **string**, not a Lisp object like:

```elisp
(json-encode '(("key" . "foo	bar")))
```

In the latter case, `json-encode` will automatically output:

```json
{"key":"foo\\tbar"}
```

No need for `erw/json--safe`.

---

### üß† So Why Might You Still Need Your Own Preprocessing?

Use your `erw/json-safe` / `erw/json--safe` when:

,* You get JSON **as a string from elsewhere** (not Lisp).
,* You want to **clean, fix, or normalize** it before parsing or writing.
,* You're doing things like applying `jq` to **hand-written or external JSON**, not generated from `json-encode`.

---

### ‚úÖ TL;DR

| Use Case                                                | Built-in Handles It? | Use Your Preprocessor? |
| ------------------------------------------------------- | -------------------- | ---------------------- |
| You build JSON from Lisp and use `json-encode`          | ‚úÖ Yes                | ‚ùå No                   |
| You receive a raw JSON string (from API, buffer, noweb) | ‚ùå No                 | ‚úÖ Yes                  |
| You need to patch bad or exotic characters in JSON text | ‚ùå No                 | ‚úÖ Yes                  |

---

Let me know if you want to expand your safe-replacements to cover more JSON troublemakers (e.g. smart quotes, non-ASCII whitespace, etc.).
\#+end\_src
#+end_src

**** preamble

#+header: :noweb-ref el-filesys
#+begin_src emacs-lisp
  (load-file "../el/list.el")
#+end_src

**** module
***** safe

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defconst erw/json-safe-alist
    '(("\t" . "\\\\t"))
    "An association list of (REGEXP . REPLACEMENT) pairs to make strings JSON-safe.")
#+end_src

#+RESULTS:
: erw/json-safe-alist

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/json--safe (string &rest re-rep)
    "Make a STRING JSON-safe by replacing REGEXP-REPLACEMENT pairs in RE-REP"
    (if (null re-rep)
        string
      (let* ((pair (car re-rep))
             (re (car pair))
             (rep (cdr pair))
             (result (replace-regexp-in-string re rep string)))
        (apply 'erw/json--safe result (cdr re-rep)))))
#+end_src

#+RESULTS:
: erw/json--safe


#+header: :noweb-ref el-example
#+header: :results verbatim
#+begin_src emacs-lisp
  (erw/json--safe "{ \"key\": \"foo	bar\" }" '("\t" . "\\\\t"))
#+end_src

#+RESULTS:
: "{ \"key\": \"foo\\tbar\" }"

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (defun erw/json-safe (string)
    "Recursively apply REGEXP-REPLACEMENT pairs in RE-REP to STRING."
    (apply 'erw/json--safe string erw/json-safe-alist))
#+end_src

#+RESULTS:
: erw/json-safe

#+header: :noweb-ref el-example
#+header: :results verbatim
#+begin_src emacs-lisp
  (erw/json-safe "{ \"key\": \"foo	bar\" }")
#+end_src

#+RESULTS:
: "{ \"key\": \"foo\\tbar\" }"

*** shell
**** module
***** jq

#+header: :noweb-ref el-shell
#+begin_src emacs-lisp
  (cl-defun erw/jq-file (&key filter file options)
    "Apply a jq FILTER to a JSON FILE and return the result."
    (let* ((parts (delq nil (append (list "jq") options (list (format "'%s'" filter) file)))) (command (string-join parts " ")))
;;    (message "DEBUG: parts: %s" parts)
;;    (message "DEBUG: command: %s" command)
    (shell-command-to-string command)))
#+end_src

#+RESULTS:
: erw/jq-file

***** string

#+header: :noweb-ref el-json
#+begin_src emacs-lisp
  (cl-defun erw/jq-string (&key filter string options)
    "Apply a jq filter to a JSON string and return the result."
    (let* ((temp-file (make-temp-file nil nil ".json"))
           (result (progn
                     (with-temp-file temp-file
                       (insert string))
                     (erw/jq-file :filter filter :file temp-file :options options))))
      (delete-file temp-file)
      (format "%s" result)))
#+end_src

#+RESULTS:
: erw/jq-string

#+header: :noweb-ref el-example
#+header: :results raw
#+header: :var json-object=(org-babel-ref-resolve "json-foo")
#+header: :wrap src json
#+begin_src emacs-lisp  
  (erw/jq-string :filter "." :string json-object :options '("-c"))
#+end_src

#+RESULTS:
#+begin_src json
{"key":"X"}
#+end_src

*** list
**** module
***** plist-if
#+header: :noweb-ref el-list
#+begin_src emacs-lisp
  (cl-defun erw/plist-if (&rest keyval-list)
    "Return a plist containing only the key-value pairs from KEYVAL-LIST
whose values are non-nil."
    (let ((result nil))
      (while keyval-list
        (let ((key (pop keyval-list))
              (value (pop keyval-list)))
          (when value
            (setq result (append result (list key value))))))
      result))
#+end_src

#+RESULTS:
: erw/plist-if

#+header: :results raw verbatim
#+begin_src emacs-lisp
  (plist-get (erw/plist-if :foo "foo" :bar nil :qux "qux") :qux)
#+end_src

#+RESULTS:
"qux"

*** noweb-ref
**** preamble

#+header: :noweb-ref el-filesys
#+begin_src emacs-lisp
  (load-file "../el/shell.el")
#+end_src

**** module
***** expand

#+header: :noweb-ref el-noweb
#+begin_src emacs-lisp
  (cl-defun erw/noweb-ref-expand (&key regex)
    "Expands all source blocks whose :noweb-ref matches REGEX and returns their expanded contents, joined by SEP."
    (let ((results '()))
      (org-element-map (org-element-parse-buffer) 'src-block
        (lambda (src)
          (let* ((begin (org-element-property :begin src))
                 (info (save-excursion
                         (goto-char begin)
                         (org-babel-get-src-block-info t)))
                 (params (nth 2 info))  ; header arguments parsed by org-babel
                 (ref (cdr (assoc :noweb-ref params))))
            ;; (message "DEBUG parsed params: %S" params)
            (when (and ref (string-match-p regex ref))
              (let ((expanded (org-babel-expand-noweb-references info)))
                (push expanded results))))))
      (nreverse results)))
#+end_src

#+RESULTS:
: erw/noweb-ref-expand

***** collect

#+header: :noweb-ref el-noweb
#+begin_src emacs-lisp
  (cl-defun erw/noweb-ref-collect (&key head ref-list tail)
    "Builds a regex from REF-LIST with optional HEAD and TAIL anchors, then forwards to `erw/noweb-ref-expand`."
    (let* ((regex-body (mapconcat #'identity ref-list "\\|"))
           (regex (concat (or head "") "\\(" regex-body "\\)" (or tail "")))
           (args `(:regex ,regex)))
      (apply #'erw/noweb-ref-expand args)))
#+end_src

#+RESULTS:
: erw/noweb-ref-collect

#+RESULTS:
: foobar

***** encode

#+header: :noweb-ref el-noweb
#+begin_src emacs-lisp
  (cl-defun erw/noweb-ref-encode
      (&key key-list head ref-list tail parse-fn encode-fn)
    "Expand noweb REF-LIST, each surrounded by HEAD and TAIL.
  PARSE-FN parses the raw strings; 
  ENCODE-FN turns parsed data into final output.
  When provided, KEY-LIST is passed to ENCODE-FN."
    (let* ((raw-blocks (erw/noweb-ref-collect :head head :ref-list ref-list :tail tail))
           (parsed-list (mapcar parse-fn raw-blocks)))
      (when (and key-list
                 (/= (length key-list) (length parsed-list)))
        (error "key-list and parsed-list must be of equal length"))
      (funcall encode-fn
               (if key-list
                   (cl-pairlis key-list parsed-list)
                 parsed-list))))
#+end_src

#+RESULTS:
: erw/noweb-ref-encode

**** example

#+header: :noweb yes
#+header: :results verbatim
#+begin_src emacs-lisp
  (string-join
   (erw/noweb-ref-expand :regex "sh-\\(foo\\|bar\\)") "\n")
#+end_src

#+RESULTS:
: "echo 'Hello, world!'
: echo 'Hello, universe!'"

#+header: :var head="^json-"
#+header: :var ref-list='("foo" "bar")
#+header: :var tail="$"
#+begin_src emacs-lisp
   (erw/noweb-ref-encode
    :head head
    :ref-list ref-list
    :tail tail
    :parse-fn 'json-read-from-string
  :encode-fn 'json-encode-array)
#+end_src

#+RESULTS:
: [{"key":"X"},{"key":"Y"}]

#+header: :var head="^json-"
#+header: :var ref-list='("foo" "bar")
#+header: :var tail="$"
#+header: :var key-list='("foo" "bar")
#+begin_src emacs-lisp
  (erw/noweb-ref-encode
   :head head
   :ref-list ref-list
   :tail tail
   :key-list key-list
   :parse-fn 'json-read-from-string
   :encode-fn 'json-encode)
#+end_src

#+RESULTS:
: {"foo":{"key":"X"},"bar":{"key":"Y"}}

#+header: :var head="^json-"
#+header: :var ref-list='("foo" "bar" "qux")
#+header: :var tail="$"
#+header: :var key-list='("foo" "bar" "qux")
#+begin_src emacs-lisp
  (erw/noweb-ref-encode
   :head head
   :ref-list ref-list
   :key-list key-list
   :parse-fn 'json-read-from-string
   :encode-fn 'json-encode)
#+end_src

#+RESULTS:
: {"foo":{"key":"X"},"bar":{"key":"Y"},"qux":[{"key":"W"},{"key":"Z"}]}

*** org
**** module
***** element
****** code

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/filter-block-names (regex &optional file)
    "Filter the source block names using REGEX in FILE."
    (let ((block-names (reverse (org-babel-src-block-names file))))
      (cl-remove-if-not (lambda (block) (string-match-p regex block)) block-names)))
#+end_src

#+RESULTS:
: erw/filter-block-names

#+begin_src emacs-lisp
  (defun erw/element-headers-as-properties (element) "Element properties retrievable using plist-get"
         (flatten-list  (mapcar (lambda (string) (org-babel-parse-header-arguments string)) (org-element-property element))))
#+end_src

***** subtree
****** paste

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (cl-defun erw/org-subtree-paste
      (&key (target-file (buffer-file-name))
            (target-pos (point))
            (level-fn (lambda (level) (+ level 1))))
    "Paste into TARGET, the subtree in the clipboard.
  The level is set by LEVEL-FN; by default = point level +1"
    (interactive)
    (unless (org-kill-is-subtree-p)
      (user-error "Clipboard does not contain a valid Org subtree"))
    (let (level)
      (with-current-buffer (find-file-noselect target-file)
        (goto-char target-pos)
        (setq level (funcall level-fn (org-current-level)))
        (org-end-of-subtree)
        (org-paste-subtree level nil nil t)
        (save-buffer))))
#+end_src

#+RESULTS:
: erw/org-subtree--paste

****** promote
******* code

#+begin_src emacs-lisp
(defun erw/org-subtree-promote ()
  "Promote the current Org subtree.

If the top heading is level 1, replace it with a `#+TITLE:` line,
then promote the rest of the subtree."
  (interactive)
  (save-excursion
    (org-back-to-heading t)
    (let ((level (org-current-level))
          (title (org-get-heading t t t t))
          (heading-start (point))
          region-start region-end)
      (if (= level 1)
          (progn
            ;; Save where heading starts
            (setq region-start (progn
                                 (forward-line 1)
                                 (point)))
            (org-end-of-subtree t t)
            (setq region-end (point))

            ;; Replace heading line with #+TITLE:
            (goto-char heading-start)
            (delete-region (line-beginning-position) (1+ (line-end-position)))
            (insert (format "#+TITLE: %s\n" title))

            ;; Promote nested subtree (if any)
            (when (< region-start region-end)
              (org-map-region
               (lambda () (org-promote-subtree))
               region-start region-end)))
        ;; Otherwise just promote normally
        (org-promote-subtree)))))
#+end_src

#+RESULTS:
: erw/org-subtree-promote

***** refactor
****** define
******* code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (cl-defmacro erw/org-refactor-define (&key
      					     ((:source source-fn))
      					     ((:args args-lambda))
      					     ((:result result-lambda))
      					     ((:target target-fn)))
    `(cl-defun ,target-fn (&rest keyval)
       ,(format "Wrapper around `%s` with optional input/output transformation." source-fn)
       (let* ((result-raw (if ,args-lambda
                              (let ((args-list (apply ,args-lambda keyval)))
                                (apply ,source-fn args-list))
                            (,source-fn)))
              (result (if ,result-lambda
  			(funcall ,result-lambda result-raw)
                        (progn
  			(warn "No output function found for %s; returning raw output instead" ',target-fn)
  			result-raw))))
         result)))
#+end_src

#+RESULTS:
: erw/org-refactor-define

****** example

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
    (defun my-source-fn (x y) (+ x y))
#+end_src

#+RESULTS:
: my-source-fn

#+header: :noweb-ref el-example
#+begin_src emacs-lisp  
  (erw/org-refactor-define
   :source 'my-source-fn
   :args (lambda (&rest kv) (list (plist-get kv :x) (plist-get kv :y))) ;; ignore input
   :result (lambda (result) (* result 10))
   :target my-wrapped-fn)
#+end_src

#+RESULTS:
: my-wrapped-fn

#+header: :noweb-ref el-example
#+begin_src emacs-lisp  
  (my-wrapped-fn :x 2 :y 3) ;; => 30
#+end_src

#+RESULTS:
: 50

***** apply
****** code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (erw/org-refactor-define
   :source org-heading-components
   :target erw/org-heading-components
   :args nil
   :result (lambda (list)
             (let ((keyval-list '(:level 0 :reduced-level 1 :todo-keyword 2 :priority 3 :headline 4 :tags 5))
                   (result '()))
               (while keyval-list
                 (let ((key (pop keyval-list))
                       (pos (pop keyval-list)))
                   (push key result)
                   (push (nth pos list) result)))
               (nreverse result))))
#+end_src

#+RESULTS:
: erw/org-heading-components

***** global
******* code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (cl-defun erw/org-global-header-position-next (&optional buffer)
    "Return the BUFFER position where the next global header line (e.g. `#+property:`) should be inserted."
    (with-current-buffer (or buffer (current-buffer))
      (save-excursion
        (goto-char (point-min))
        (while (looking-at "^#\\+\\w+:")
          (forward-line 1))
        (point))))
#+end_src

**** property
***** define
****** code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (cl-defmacro erw/org-property-define (&key
                                        ((:name name-symb))
                                        ((:key key-string))
                                        ((:value value-lambda)))
    "Create a function NAME-SYMB to set Org property KEY-STRING using VALUE-LAMBDA."
    (let ((name-symb (or name-symb
                         (intern (concat "erw/org-property-" key-string)))))
      `(cl-defun ,name-symb (&rest keyval)
         ,(format "Set the Org property %s using a computed value." key-string)
         (let ((value (save-excursion (apply ,value-lambda keyval))))
           (org-set-property ,key-string value)))))
#+end_src

#+RESULTS:
: erw/org-property-define

***** apply
****** code

#+header: :noweb-ref el-org
#+begin_src emacs-lisp
  (erw/org-property-define
   :key "parent-id"
   :value (lambda ()
            (when (org-up-heading-safe)
              (org-id-get-create))))
#+end_src

#+RESULTS:
: erw/org-property-parent-id

*** src-block
**** module
***** info
#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/src-block-info (name &optional no-eval)
    "Gets info of block NAME"
    (let ((block (org-babel-find-named-block name)))
  	 (when block
  		 (save-excursion
                     (goto-char block)
                     (org-babel-get-src-block-info no-eval)))))
#+end_src

#+RESULTS:
: erw/src-block-info

#+header :noweb-ref el-example
#+begin_src emacs-lisp
(erw/src-block-info "json-foo-bar")
#+end_src

#+RESULTS:
| json | { "key" : "X" } | ((:colname-names) (:rowname-names) (:result-params replace) (:result-type . value) (:results . replace) (:exports . code) (:tangle . no) (:hlines . no) (:noweb . no) (:cache . no) (:session . none)) |   | json-foo-bar | 1239 | (ref:%s) |

#+header: :noweb-ref el-example
#+header: :results verbatim raw
#+begin_src emacs-lisp
  (erw/src-block-properties "bar-qux" :header)
#+end_src

#+RESULTS:
((":var value=\"qux\""))

#+header :noweb-ref el-example
#+begin_src emacs-lisp
  (org-babel-parse-header-arguments
   (mapconcat (lambda (pair) (concat (car pair) " " (cadr pair)))
              (erw/src-block-properties "bar-qux" :header)
              " "))
#+end_src

#+RESULTS:
: ((:var . value="qux"))

*** table
**** module
***** field-address
****** code
#+header: :noweb-ref el-table
#+begin_src emacs-lisp
  (defun erw/function-table-field-address (index)
    "Table address for field INDEX"
    (format "@1$%d..@>$%d" index index))
  (defalias 'erw/field-address 'erw/function-table-field-address)
#+end_src

#+RESULTS:
: erw/field-address

****** example
#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (erw/field-address 2)
#+end_src

#+RESULTS:
: @1$2..@>$2

***** get-range
****** code
#+header: :noweb-ref el-table
#+begin_src emacs-lisp
  (defun erw/function-table-get-range-at-file (tbl-id range-address &optional file-name)
    "Get list of values in RANGE-ADDRESS from TBL-ID at FILE-NAME.
       Credits: https://redd.it/r2nig7"
    (let ((file-name (or file-name (buffer-file-name (current-buffer)))))
      (with-current-buffer (find-file-noselect file-name)
        (let ((result-with-properties
               (org-table-get-remote-range tbl-id range-address)))
          (mapcar (lambda (s)
                    (substring-no-properties (substring s 1 -1)))
                  result-with-properties)))))
  (defalias 'erw/table-range 'erw/function-table-get-range-at-file)
#+end_src

#+RESULTS:
: erw/table-range

****** example

#+header: :noweb-ref el-example
#+header: :results value verbatim
#+begin_src emacs-lisp
(erw/table-range "tbl-foo-bar-string" (format "@1$%d..@>$%d" 2 2))
#+end_src

#+RESULTS:
: ("x" "y")

***** lookup
****** code
#+header: :noweb-ref el-table
#+begin_src emacs-lisp
    (defun erw/function-table-lookup (tbl-id key &optional file-name key-index value-index match-predicate)
      "Lookup field KEY-INDEX and return corresponding entry in field VALUE-INDEX from table TBL-ID."
      (interactive)
      (let ((key-address (erw/field-address (or key-index 1)))
            (value-address (erw/field-address (or value-index 2)))
            (file-name (or file-name (buffer-file-name (current-buffer))))
            (match-predicate (or match-predicate 'string-match-p)))
        (let ((key-range (erw/table-range tbl-id key-address file-name))
              (value-range (erw/table-range tbl-id value-address file-name)))
          (org-lookup-first key key-range value-range 'string-match-p))))
  (defalias 'erw/table-lookup 'erw/function-table-lookup)
#+end_src

#+RESULTS:
: erw/table-lookup

****** example

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
(erw/table-lookup "tbl-foo-bar-string" "foo")
#+end_src

#+RESULTS:
: x

#+header: :noweb-ref el-example
#+begin_src emacs-lisp
(erw/table-lookup "tbl-foo-bar-string" "bar")
#+end_src

#+RESULTS:
: y

** sh
*** test-cases

#+header: :noweb-ref sh-foo
#+begin_src sh
  echo 'Hello, world!'
#+end_src

#+header: :noweb-ref sh-bar
#+begin_src sh
  echo 'Hello, universe!'
#+end_src

#+name: bar-qux
#+header: :var value="qux"
#+begin_src sh
  echo "${value}"
#+end_src

** json
*** test-cases

#+header: :noweb-ref json-foo
#+begin_src json
  { "key" : "X" }
#+end_src

#+header: :noweb-ref json-bar
#+begin_src json
  { "key" : "Y" }
#+end_src

#+header: :noweb-ref json-qux
#+begin_src json
 [{"key":"W"},{"key":"Z"}]
#+end_src

* tangle
** filesys
:PROPERTIES:
:header-args: :tangle ../el/filesys.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-filesys>>
#+end_src

** shell
:PROPERTIES:
:header-args: :tangle ../el/shell.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-shell>
#+end_src

** json
:PROPERTIES:
:header-args: :tangle "../el/json.el"
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-json>>
#+end_src

** list
:PROPERTIES:
:header-args: :tangle ../el/list.el
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-list>>
#+end_src

** noweb
:PROPERTIES:
:header-args: :tangle "../el/noweb.el"
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-noweb>>
#+end_src

** org
:PROPERTIES:
:header-args: :tangle "../el/org.el"
:END:

#+header: :noweb yes
#+begin_src emacs-lisp
  <<el-license>>
  <<el-org>>
#+end_src

#+RESULTS:
: erw/noweb-concat

* scratch

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/src-block-element (name) "Return the whole block element"
         (save-excursion
  	 (goto-char (org-babel-find-named-block name))
  	 (org-element-at-point)))
#+end_src

#+header :noweb-ref el-example
#+begin_src emacs-lisp
  (erw/src-block-element "bar-qux")
#+end_src

#+header: :noweb-ref el-beta
#+begin_src emacs-lisp
  (defun erw/src-block-properties (name &rest properties)
    "Return block properties from the named block element. Defaults to :value if no properties are given."
    (let* ((element (erw/src-block-element name))  ;; Use erw/src-block-element to get the block
           (props (if properties
                      properties
                    '(:value))))  ;; Default to :value if no properties are provided
      (mapcar (lambda (prop)
                (org-element-property prop element))  ;; Get each property using org-element-property
              props)))
#+end_src

** package

#+header: :noweb-ref el-leaveout
#+begin_src emacs-lisp
  (use-package dash
    :ensure t)
#+end_src

** id-link
*** const

#+property: p


#+begin_src emacs-lisp
    (defconst erw/org-property-rdf
  '(:primary-key "rdf-like"
    :secondary-key '(
  		   :predicate
  		   :object
  		   )
      
      "db-like" "Main key")
#+end_src

#+begin_src emacs-lisp
  (defconst erw/org-property-db-optional-keys '(collection predicate type) "Optional secondary keys")
#+end_src

#+RESULTS:
: erw/org-property-db-optional-keys

*** set-helper

#+begin_src emacs-lisp
  (defun erw/org-property-plist-helper (primary-key secondary-key-list &rest plist)
    ""
      (let ((parts '()))
        ;; Collect optional key-value pairs
        (dolist (k secondary-key-list)
          (let ((val (plist-get plist k)))
            (when val
              (push (format ":%s %s" (substring (symbol-name k) 1) val) parts))))
        (let ((property-value (string-join (nreverse parts) " "))
              (property-name (if (org-entry-get (point) primary-key)
                                 (concat primary-key "+")
                               primary-key)))
          (org-set-property property-name property-value)))))
#+end_src

#+RESULTS:
: set-erw-graph-property

*** set

#+begin_src emacs-lisp
(eval-and-compile
  (let* ((optional-args (mapcar (lambda (k) (list k)) erw/org-property-db-optional-keys))
         (arglist `(&key ,@optional-args id secondary-key))
         (forward-body
          `(apply #'erw/org-property-db-set-helper
                  "erw-link"
                  ',erw/org-property-db-optional-keys
                  (list
                   ,@(apply #'append
                            (mapcar (lambda (k) `(',k ,k))
                                    (append erw/org-property-db-optional-keys '(:id :secondary-key))))))))
    (eval `(cl-defun erw/org-property-db-set ,arglist
             ,(format "Auto-generated wrapper forwarding to `erw/org-property-db-set-helper`.\nOptional keys: %s"
                      erw/org-property-db-optional-keys)
             ,forward-body))))
#+end_src


#+begin_src emacs-lisp
    (cl-defun my-func (source-file
    		   &key
           		   ((:directory directory-string))
           		   ((:do-trash trash-bool)))    
      "Interactively clone SOURCE-FILE to a uniquely named one."
      (interactive "fEnter source file")
      ;; (message "DEBUG: %s" source-file)
      )
#+end_src

#+RESULTS:
: my-func

#+begin_src emacs-lisp
  (erw/filesys-unique-clone :source "/home/erwann/src/org/AiSv8K.org")
#+end_src

#+RESULTS:
: /home/erwann/unique/xxYG8M.org

* trash
** org

#+begin_src emacs-lisp
  (defun erw/org-subtree-paste-interactive ()
    "Forwards to `erw/org-subtree-paste` at point"
    (interactive)
    (erw/org-subtree-paste (buffer-file-name) (point)))
#+end_src

#+RESULTS:
: erw/org-subtree-paste

** shell
*** code

#+header: :noweb-ref el-shell
#+begin_src emacs-lisp
  (defun erw/sh-check (command &optional re)
    "Issues a warning if the shell does not match RE; then executes shell COMMAND."
    (let ((re (or re "bash$")))
      (unless (string-match-p re (format "%s" shell-file-name))
        (warn "Warning: expecting shell to match %s; got %s" re shell-file-name))
      (shell-command-to-string command)))
#+end_src

#+RESULTS:
: erw/sh-check

*** example

#+header: :noweb-ref el-example
#+header: :results code
#+begin_src emacs-lisp
  (erw/sh-check "echo \"foo\"" "fish$")
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
"foo\n"
#+end_src

** string
*** wrap-single-quotes
**** code
#+begin_src emacs-lisp
  (defun erw/function-string-wrap-single-quotes (string)
    "Wraps STRING with single quotes if absent."
    (if (string-match-p "^'.*'$" string)
       string
      (concat "'" string "'")))
  (defalias 'erw/wrap-single-quotes 'erw/function-string-wrap-single-quotes)
#+end_src

#+RESULTS:
: erw/wrap-single-quotes

**** example
#+header: :noweb-ref el-example
#+begin_src emacs-lisp
  (let ((string (buffer-file-name (current-buffer))))
    (format "before: %s\nafter: %s" string 
             (funcall 'erw/wrap-single-quotes string)))
#+end_src

#+RESULTS:
: before: /home/erwann/.emacs.d/routinel.org
: after: '/home/erwann/.emacs.d/routinel.org'

